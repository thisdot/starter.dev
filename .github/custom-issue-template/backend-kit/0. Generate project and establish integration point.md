# Background

To make tasks parallelizable, we should create kits via integration branches to make PRs smaller and easier to read while not breaking the upstream build. Integration branches may be cleaner and easier to implement in isolation as kits are isolated to their own directory anyway.

# Kit Naming Guidelines

Kits are named to reflect the key technologies used to comprise the kit. For backend kits, this is defined as: <framework>-<middleware>-<store>. This is to help with uniqueness in naming different kits.

- Framework: This should be the main application framework used to define the backend service. Some examples for this value are: ExpressJS, NestJS, Serverless Framework, etc. Ideally, this is technology responsible for running a server when the “dev” script command is run that starts a local server.
- Special tech: This is a piece of technology that helps distinguish this kit from other backend kits using the same key framework and store. If using GraphQL as an API, specifying which middleware is a great option, e.g. Apollo, Relay, etc. If using a different RPC, defining the implementation is ideal. If using standard REST, it is okay to omit this feature of the name.
- Store: This should represent the ORM or Data Source selected for the kit. If using a database without an ORM, the database name is acceptable. If using an ORM (TypeORM, Prisma, Sequelize, etc.), that should be used here instead. If there is no ORM or database and a CMS or 3rd party API is used instead, the selected CMS should be used, but if it’s strictly a 3rd party API, use the convention “headless” to describe the kit.

# Acceptance

- [ ] Generate new project in the `starters/` creating a name that includes `<framework>-<special-tech>-<store>` format
- [ ] Change the name and description in the package.json
- [ ] Merge change into an integration branch
