# Vue 3, XState, and CSS Starter Kit

This starter kit uses [Vue 3](https://vuejs.org/), [XState](https://xstate.js.org/) for state management, and pure CSS for styling.

**How to use this starter kit**

```sh
npm create @this-dot/starter -- --kit vue3-xstate-css
```

<sub>(use any of `npm` / `yarn` / `pnpm`)</sub>

If you'd prefer manual installation, you can follow this process:

> Note: The command below clones the entire repository, including other starter kits.

```sh
git clone https://github.com/thisdot/starter.dev.git
```

Copy and rename the "starters/vue3-xstate-css" directory to the name of your new project.

## Tech Stack

- [Vue 3](https://vuejs.org/)
- [XState](https://xstate.js.org/)

For styling, this kit uses pure CSS. Since we're making use of Vue's single file component structure, we've set our styles to be scoped to each component.

This kit is also set up to show the XState visualizer when run locally, to help you see what your state machines look like and how they work.

### Included Tooling

- [Vite](https://vitejs.dev/) - build / bundle tool
- [Vue Router](https://router.vuejs.org/) - navigation
- [Cypress](https://docs.cypress.io/guides/component-testing/overview) - component / unit testing
- [Storybook](https://storybook.js.org/) - documents component designs
- [ESLint](https://eslint.org/) - code consistency and best practices
- [Prettier](https://prettier.io/) - code formatting

**Type Support for `.vue` Imports in TS**

This project is setup to handle TypeScript files. However, TypeScript cannot handle type information for `.vue` imports by default, so we replace the `tsc` CLI with `vue-tsc` for type checking. In editors, we need [TypeScript Vue Plugin (Volar)](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin) to make the TypeScript language service aware of `.vue` types.

## Getting Started

### Prerequisites

- [Node.js 16.8](https://nodejs.org/) or later installed

### Development

Once you've generated your new starter kit following the instructions above:

- `cd` into your project directory and run `npm install` to install the dependencies.
- Run `npm run dev` to start the development server.
- Open your browser to <http://localhost:5173> to see the included example code running. This will also launch the XState inspector for you.

## Available commands

`npm run dev` - starts the local development server

`npm run build-only` - handles compiling and minifying your files
`npm run type-check` - type checks your files
`npm run build` - combines the previous two commands to type-check your files then compile and minify them for production

`npm run preview` - will run the site locally based on your production built files generated by the build commands

`npm run test:unit` - runs Cypress component tests in a headless state, as they would run in a CI environment
`npm run test:unit:dev` - runs Cypress component tests in a headed state, so you can walk through individual tests

`npm run lint` - checks your files for common coding errors
`npm run format` - formats all of your files

`npm run storybook` - runs Storybook locally
`npm run build-storybook` - builds a version of your Storybook stories that you can host somewhere

## Project Details

### Project Structure

The main folder you'll interact with is the `src` folder. This is split into a few different folders to help keep concerns organized.

- `assets`: for global CSS or images that will need to be bundled with your code
- `components`: small, reusable pieces of code that don't need any specific store logic
- `machines`: to hold our state machines
- `router`: routing configuration
- `stories`: Storybook stories
- `utils`: any reusable helper functions you might need to create
- `views`: the actual "views" or pages you assemble, which will combine pieces from all the previous folders
- `views/__tests__`: Cypress tests for our assembled views

### Using XState

**The visualizer**

To get the visualizer working locally, we're using the `@xstate/inspect` package and importing it within the `main.ts` file. Then within our components, when we want to be able to visualize our state machine we pass the `devtools: true` option when we call `useMachine`. The visualizer allows us to see what a particular state machine looks like by letting us manually trigger different states and actions. You can even directly change the machine within the visualizer to test out changes you might want to make. Just make sure that if you want to keep those changes you copy it back into your machine file!

**State vs Context**

You'll notice that within both of our example machines, we're using a `context` object. You can read more specifics about how this works [in the XState documentation on context](https://xstate.js.org/docs/guides/context.html#initial-context), but in general the context stores data that might be quantitative in nature (like numbers, strings, or objects).

In [the introduction to state machines documentation](https://xstate.js.org/docs/guides/introduction-to-state-machines-and-statecharts/#states), they give the example of a dog's "state" as being asleep or awake. A dog can't be both asleep and awake at the same time - it has to be one or the other. The same is true of our states. You'll see this best in the `greetMachine.ts` file. We're either loading our data, we received our complete data, or we received our error data. The machine can only be in one of these three states.

We use the context to store information that might change as we go through different states. In our greetMachine, we use the context to store the query we're sending, the message we get back, and any potential error text we get back. Since the items here are arbitrary and can change as our machine moves through it's states, we store these in the context object.

**Passing props to a machine**

We can pass props to our machines, if we have initial data we need to provide them from our components. The greeting example in this kit does just this - we're setting an initial prop when we navigate to the example page (this is set in the router's index file), and then in our `GreetView.vue` file we're defining the prop we expect and passing it to our machine.

The `greetMachine` is then set similar to a standard JS function to accept a parameter that it can then use within the machine (in this case we're setting it as our default "query" value and passing it to our fetch service).

**TS Support in Machines**

XState offers us a `schema` option in our machines to allow us to type our state charts. We can use this to help strongly type our context and events. This will give us better tips when using our machine and help ensure we know what types of values we're expecting when we use them.

**Machine Configuration**

The `createMachine` call that we use to build machines accepts two objects.

The first object is always present, and specifies the name of our machine, it's initial state, any local context it needs, and the states our machine can be in.

```js
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  // Machine identifier
  id: 'light',

  // Initial state
  initial: 'green',

  // Local context for entire machine
  context: {
    elapsed: 0,
    direction: 'east',
  },

  // State definitions
  states: {
    green: {
      /* ... */
    },
    yellow: {
      /* ... */
    },
    red: {
      /* ... */
    },
  },
});
```

Eventually our states will need to define actions, services, or guards. These can be written directly within the state itself, or they can be passed to the optional second object in the `createMachine` function, and then referenced in the state by their name.

```js
const lightMachine = createMachine(
  {
    id: 'light',
    initial: 'green',
    states: {
      green: {
        // action referenced via string
        entry: 'alertGreen',
      },
    },
  },
  {
    actions: {
      // action implementation
      alertGreen: (context, event) => {
        alert('Green!');
      },
    },
    guards: {
      /* ... */
    },
    services: {
      /* ... */
    },
  }
);
```

You'll see both options in this kit - the `counterMachine` has it's actions defined separately, and the `greetMachine` has the actions inline in the state but the service defined separately. Either option is valid. You might start with your actions inlined to ensure they work, and then separate them out to make them easier to read and debug.

**PredictableActionArguments**

You'll see the option `predictableActionArguments: true` within our machines. This is recommended per the docs, and will be a default option in the next version. This flag means that XState will always call an action with the direct event that triggered it.

### Vue 3 Benefits

Since we're using Vue 3, we're able to make use of the composition API. This means we can use the `setup` option in our component's script tags, which lets us define our variables and function in a style that looks a bit more like standard JS. We import any Vue specific functions or lifecycle methods that we need, and then use them like regular functions. With this method, we don't have to have an object that defines all of the values our component can use - it just reads like standard variables and functions.

### Cypress Testing

The only specific setup thing we needed to do to enable component testing was to add the `mount` command to Cypress. They have packages available for multiple common frameworks which will provide the functionality for you - all we have to do is go into our `cypress/support/component.ts` file, import the `mount` function, and then tell Cypress to add that command. This lets us mount our individual components so we can then run our Cypress tests directly on that component.

That `cypress/support/component.ts` file is also where you'll import any global styles your components might need.

## Deployment

Deploying to a hosting service like [Netlify](https://www.netlify.com) or [Vercel](https://vercel.com) is as straight forward as hooking up your repository to the service and letting the service auto detect the configuration for you.

The main question they're likely to ask is what command to run to build your site, which for this kit is the `build-only` command (or `build` if you want it to run type checking first).
